  ![](https://i.imgur.com/jZqxa2o.png)  

***    
**Ссылки на конкретный паттерн**:  

 * [Adapter](#adapter)
 * [Bridge](#bridge)  
 * [Composite](#composite)
 * [Decorator](#decorator)
 * [Facade](#facade)     
 * [Flyweight](#flyweight)    
 * [Proxy](#proxy)     

***
[Adapter](#adapter)  
--------------      
![](https://refactoring.guru/images/patterns/content/adapter/adapter-2x.png)   
  
**Адаптер** — это структурный паттерн проектирования, который преобразует интерфейс одного класса в интерфейс другого, который ожидают клиенты.    

Представим, что мы разрабатываем графический редактор. Большая часть отображаемых элементов нашего графического редактора реализуют некоторый интерфейс *Shape*. Вот мы реализовали класс *Line*, который реализует наш интерфейс *Shape*. Теперь мы хотим реализовать класс для отображения текста -*TextShape*. Мы немного подумали и поняли, что это задача достаточно сложна для нас и мы бы хотели для этих целей использовать уже готовую библиотеку для работы с текстом. Но вот незадача, в коде мы работали лишь с интерфейсам типа *Shape*, а наша библиотека никогда не слышала об этой интерфейсе, да и не должна была. Возникает вопрос, как же заставить работать библиотеку в нашем случаи. Этот вопрос решает паттерн **Адаптер**.  
  
Суть **Адаптера** заключается в том, что он реализует наш интерфейс *Shape* в терминах нашей новой библиотеки, скажем с классом *TextView*(класс нашей библиотеки). Для этих целей мы создаём наш класс *TextShape*, который реализует интерфейс *Shape* и наследуется от класса *TextView*. Давайте посмотрим:  
  
```swift
protocol Shape {
    // ...
}

class TextView {
    // ...
}

class TextShape: TextView, Shape {
    // ...
}
```

Теперь осталось реализовать методы интерфейса *Shape* используя возможности класса *TextView*. Получившийся класс *TextShape* будет удовлетворять нашему интерфейсу и работать с новой библиотекой.   
  
Нужно понимать, что **Адаптера** может работать как с классом нашей новой библиотеки, так и с объектами этого класса. Пример выше - работа с классом. Работа с объектом подразумевает хранение объекта класса *TextView*. Давайте посмотрим на это:  
  
```swift
protocol Shape {
    // ...
}

class TextView {
    // ...
}

class TextShape: Shape {
    private let textView: TextView

    init(textView: TextView) {
        self.textView = textView
    }

    // ...
}
```
   
Так в чём же их различие? Если мы адаптируем класс, то в таком случаи мы может переопределять некоторую функциональность наследуемого класса, в случаи же адаптирования по второму типу, мы этого сделать не можем, т.к. мы уже не наследуемся, а имеем лишь ссылку на объект. Но при этом если мы адаптируемся по второму типу, мы сможем работать с подклассами *TextView*, т.к. мы содержим ссылку на базовый класс, то и любой подкласс так же будет удовлетворять этому типу, что недоступно при адаптировании класса, в этом случаи мы к нему жёстко привязаны.   
  
Руководствуясь выше сказанным, будет достаточно просто определить, что вам нужен именно этот паттерн и какой его тип вы примените. 
