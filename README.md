  ![](https://i.imgur.com/jZqxa2o.png)  

***    
**Ссылки на конкретный паттерн**:  

 * [Adapter](#adapter)
 * [Bridge](#bridge)  
 * [Composite](#composite)
 * [Decorator](#decorator)
 * [Facade](#facade)     
 * [Flyweight](#flyweight)    
 * [Proxy](#proxy)     

***
[Adapter](#adapter)  
--------------      
![](https://refactoring.guru/images/patterns/content/adapter/adapter-2x.png)   
  
**Адаптер** — это структурный паттерн проектирования, который преобразует интерфейс одного класса в интерфейс другого, который ожидают клиенты.    

Представим, что мы разрабатываем графический редактор. Большая часть отображаемых элементов нашего графического редактора реализуют некоторый интерфейс *Shape*. Вот мы реализовали класс *Line*, который реализует наш интерфейс *Shape*. Теперь мы хотим реализовать класс для отображения текста -*TextShape*. Мы немного подумали и поняли, что это задача достаточно сложна для нас и мы бы хотели для этих целей использовать уже готовую библиотеку для работы с текстом. Но вот незадача, в коде мы работали лишь с интерфейсам типа *Shape*, а наша библиотека никогда не слышала об этой интерфейсе, да и не должна была. Возникает вопрос, как же заставить работать библиотеку в нашем случаи. Этот вопрос решает паттерн **Адаптер**.  
  
Суть **Адаптера** заключается в том, что он реализует наш интерфейс *Shape* в терминах нашей новой библиотеки, скажем с классом *TextView*(класс нашей библиотеки). Для этих целей мы создаём наш класс *TextShape*, который реализует интерфейс *Shape* и наследуется от класса *TextView*. Давайте посмотрим:  
  
```swift
protocol Shape {
    // ...
}

class TextView {
    // ...
}

class TextShape: TextView, Shape {
    // ...
}
```

Теперь осталось реализовать методы интерфейса *Shape* используя возможности класса *TextView*. Получившийся класс *TextShape* будет удовлетворять нашему интерфейсу и работать с новой библиотекой.   
  
Нужно понимать, что **Адаптер** может работать как с классом нашей новой библиотеки, так и с объектами этого класса. Пример выше - работа с классом. Работа с объектом подразумевает хранение объекта класса *TextView*. Давайте посмотрим на это:  
  
```swift
protocol Shape {
    // ...
}

class TextView {
    // ...
}

class TextShape: Shape {
    private let textView: TextView

    init(textView: TextView) {
        self.textView = textView
    }

    // ...
}
```
   
Так в чём же их различие? Если мы адаптируем класс, то в таком случаи мы может переопределять некоторую функциональность наследуемого класса, в случаи же адаптирования по второму типу, мы этого сделать не можем, т.к. мы уже не наследуемся, а имеем лишь ссылку на объект. Но при этом, если мы адаптируемся по второму типу, мы сможем работать с подклассами *TextView*, т.к. мы содержим ссылку на базовый класс, то и любой подкласс так же будет удовлетворять этому типу, что недоступно при адаптировании класса, в этом случаи мы к нему жёстко привязаны.   
  
Руководствуясь выше сказанным, будет достаточно просто определить, что вам нужен именно этот паттерн и какой его тип вы примените. 

***
[Bridge](#bridge)  
--------------      
![](https://refactoring.guru/images/patterns/content/bridge/bridge-2x.png)   
  
**Мост** — это структурный паттерн проектирования, который разделяет абстракцию и реализацию на две иерархии.   
  
Если для некоторой абстракции существует несколько реализаций, то обычно создают интерфейс и в каждом классе его реализующим, определяют конкретную реализацию. Всё вроде выглядит вполне обычно образом, но при таком подходе вы жёстко привязываете реализацию к абстракции.   
  
Рассмотрим несколько примеров. Представьте, что у нас есть некоторый интерфейс *Фигура*. Далее, реализуя этот интерфейс мы получаем следующие классы: *Круг*, *Квадрат* и т.д. Нам достаточно легко добавлять новые фигуры и проблем никаких мы пока не видим. Теперь давайте задумаемся о рисовании этих фигур. На одной платформе фигуры рисуются одним способом, а на другой платформе - иначе. То есть теперь для рисования конкретной фигуры на той или иной платформе, нам нужно создавать подкласс. Что в конце-концов приводит к сложной иерархии. Давайте посмотрим:  
  
```swift
protocol Shape {
    func draw()
    // ...
}

//#######################

class Circle: Shape {
    func draw() {
        // ...
    }

    // ...
}

class Square: Shape {
    func draw() {
        // ...
    }

    // ...
}

//#######################

class CircleWindowsDraw: Circle {
    ovveride func draw() {
        // ...
    }

    // ...
}

class CircleLinuxDraw: Circle {
    ovveride func draw() {
        // ...
    }

    // ...
}

class SquareWindowsDraw: Square {
    ovveride func draw() {
        // ...
    }

    // ...
}

class SquareLinuxDraw: Square {
    ovveride func draw() {
        // ...
    }

    // ...
}
```

Для каждой новой добавленной фигуры, мы вынуждены писать обе реализации. А что если фигур и платформ будет достаточно много. Всё это превратится в огромную кашу.   
  
Другим пример будет написание предметов и их экзаменов. Представим интерфейс - *Предмет*. Реализуем наш интерфейс конкретными предметам: *Физика*, *Математика*, *Русский Язык*, ... . Каждый из предметов может сдаваться как в виде устного экзамена, так и письменного. И снова для каждого из предметов нам нужно писать по два класса с нужной реализацей сдачи экзамена. Получим клубок взаимосвязанных классов.   
  
Паттерн **Мост** решает такого рода проблему, разделяя абстракцию и реализацию на два интерфейса. В нашем первом примере по одну строну оставим лишь интерфейс *Фигура* и классы его реализующие. По другую же сторону мы определим новый интерфейс, который будет определять основные методы рисования фигур. Теперь реализую этот интерфейс, мы добавим в систему конкретные реализации под разные платформы, которые не будут привязаны к фигурам. Единственное, в таком случаи в интерфейс *Фигура* нужно добавить ссылку на конкретный интерфейс рисования. Всё выглядит достаточно просто:

```swift
protocol Shape {
    var implement: Draw { get }
    func draw()
    // ...
}

//#######################

protocol Draw {
    func drawFigure()
    // ...
}

//#######################

class WindowsDraw: Draw {
    func drawFigure() {
        // ...
    }

    // ...
}

class LinuxDraw: Draw {
    func drawFigure() {
        // ...
    }

    // ...
}

//#######################

class Circle: Shape {
    let implement: Draw

    init(draw: Draw) {
        self.implement = draw
    }

    func draw() {
        implement.drawFigure()
        // ...
    }

    // ...
}

class Square: Shape {
    let implement: Draw

    init(draw: Draw) {
        self.implement = draw
    }

    func draw() {
        implement.drawFigure()
        // ...
    }

    // ...
}
```
  
Как видно, абстракция и реализация теперь отделены и не зависят друг от друга. Мы с лёгкость можем добавлять новые фигуры и добавлять новые платформы. Обе стороны моста могут наращивать функционал независимо. При этом, мы всегда может добавить нужный нам отрисовщик в нашу фигуру, не зная заранее какой из них нам может понадобиться.   
  
```swift  
// Main

let draw = LinuxDraw()  
// с другой стороны мы могли бы сделать и так WindowsDraw()  
// и нам непришлось ничего менять в нашей абстракции

let circle = Circle(draw: draw)
let square = Square(draw: draw)  

circle.draw()
square.draw()
```

